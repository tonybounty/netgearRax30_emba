<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary name: </span><span class="orange">epi_ttcp</span></pre>
<pre>[</span><span class="orange">*</span>] Emulator used: </span><span class="orange">qemu-arm-static</span></pre>
<pre>[</span><span class="orange">*</span>] Using root directory: </span><span class="orange">/logs/firmware/firmware_binwalk_emba/_firmware.extracted/squashfs-root</span> (</span><span class="orange">1/1</span>)</pre>
<pre>[</span><span class="orange">*</span>] Using CPU config: </span><span class="orange">NONE</span></pre>
<pre>[</span><span class="orange">*</span>] Emulating binary: </span><span class="orange">/usr/sbin/epi_ttcp</span></pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">NONE</span></pre>
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>sockbufsndsize=16384, sockbufrcvsize=131072, sockbufsize=73728, </pre>
<pre># tcp receiver #</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">-v</span></pre>
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>ttcp-r: bind: Address already in use</pre>
<pre>ttcp-r: errno=98</pre>
<pre>ttcp-r: start time Sun Jan 15 15:17:18 2023</pre>
<pre>ttcp-r: File-Descriptor 0x3 Opened</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">-V</span></pre>
<pre>ttcp.c $- CERN Revision: 3.8 (dev level) -$ Epigram 15-jul-98</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">-h</span></pre>
<pre> Details about the reply: </pre>
<pre>   Example: </pre>
<pre>   ttcp-t: buflen=8192, nbuf=100, align=16384/0, port=5010</pre>
<pre>   ttcp-t: File-Descriptor 0x4 Opened</pre>
<pre>   # tcp sender -&gt; &lt;host&gt; #</pre>
<pre>   ttcp-t: 819200 bytes in 1.152557 real seconds = 694.109 KB/sec +++</pre>
<pre>   ttcp-t: 100 I/O calls, 11.526 msec(real)/call, 0.213 msec(cpu)/call</pre>
<pre>   ttcp-t: 0.001914user 0.019388sys 0:01real 1        0+58d 190maxrss 1+2pf 177+180csw</pre>
<pre>   ttcp-t: buffer address 0x28000</pre>
<pre>   ttcp-t: File-Descriptor  fd 0x4 Closed</pre>
<pre>   ttcp done.</pre>
<br />
<pre>cpu seconds  ==  (sec) elapse ru_utime + elapse ru_stime.</pre>
<pre>                 ru_utime == The total amount of time running in user mode.</pre>
<pre>                 ru_stime == The total amount of time spent in the system.</pre>
<pre>                             executing on behalf of the process.</pre>
<pre>real seconds ==  elapse time calculated by the system timer (date).</pre>
<pre>I/O calls    ==  I/O call to the driver.</pre>
<pre>msec/call    ==  average elapse time (Real seconds) between each I/O.</pre>
<pre>calls/sec    ==  invert of msec/call.</pre>
<pre>user         ==  (sec.msec) elaspe ru_utime.</pre>
<pre>sys          ==  (sec.msec) elapse ru_stime.</pre>
<pre>real         ==  (min:sec)  CPU seconds.</pre>
<pre>%           ==  Real seconds / CPU seconds.</pre>
<pre>(ru_ixrss)i+(ru_idrss)d</pre>
<pre>             ru_ixrss  == An integral value indicating the amount of memory </pre>
<pre>                          used by the text segment that was also shared among</pre>
<pre>                          other processes. This value is expressed in units of</pre>
<pre>                          kilobytes * seconds-of-execution and is calculated </pre>
<pre>                          by adding the number of shared memory pages in use </pre>
<pre>                          each time the internal system clock ticks, and then</pre>
<pre>                          averaging over one-second intervals.</pre>
<pre>             ru_idrss  == An integral value of the amount of unshared memory </pre>
<pre>                          in the data segment of a process (expressed in </pre>
<pre>                          units of kilobytes * seconds-of-execution).</pre>
<pre>  (ru_maxrss/2)maxrss.</pre>
<pre>             ru_maxrss == The maximum size, in kilobytes, of the used</pre>
<pre>                          resident set size. </pre>
<pre>  (ru_majflt)+(ru_minflt)pf : Page fault</pre>
<pre>             ru_majflt == The number of page faults serviced that required</pre>
<pre>                          I/O activity.</pre>
<pre>             ru_minflt == The number of page faults serviced without any</pre>
<pre>                          I/O activity. In this case, I/O activity is </pre>
<pre>                          avoided by reclaiming a page frame from the list </pre>
<pre>                          of pages awaiting reallocation. </pre>
<pre>(ru_nvcsw)+(ru_nivcsw)csw : context switch</pre>
<pre>             ru_nvcsw  == The number of times a context switch resulted </pre>
<pre>                          because a process voluntarily gave up the </pre>
<pre>                          processor before its time slice was completed. </pre>
<pre>                          This usually occurs while the process waits </pre>
<pre>                          for availability of a resource.</pre>
<pre>             ru_nivcsw == The number of times a context switch resulted </pre>
<pre>                          because a higher priority process ran or because</pre>
<pre>                          the current process exceeded its time slice.</pre>
<br />
<pre>log file format :</pre>
<pre>         buflen, nbuf(byte), bufalign(byte), bufoffset(byte)</pre>
<pre>         port, sockbufsize(byte), UserTime(sec), SysTime(sec), CPUusage(%)</pre>
<pre>         nbytes(byte), realt(sec), rate(MB/sec), I/O call,</pre>
<pre>                 hours*3600+min*60+sec</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">-help</span></pre>
<pre> Details about the reply: </pre>
<pre>   Example: </pre>
<pre>   ttcp-t: buflen=8192, nbuf=100, align=16384/0, port=5010</pre>
<pre>   ttcp-t: File-Descriptor 0x4 Opened</pre>
<pre>   # tcp sender -&gt; &lt;host&gt; #</pre>
<pre>   ttcp-t: 819200 bytes in 1.152557 real seconds = 694.109 KB/sec +++</pre>
<pre>   ttcp-t: 100 I/O calls, 11.526 msec(real)/call, 0.213 msec(cpu)/call</pre>
<pre>   ttcp-t: 0.001914user 0.019388sys 0:01real 1        0+58d 190maxrss 1+2pf 177+180csw</pre>
<pre>   ttcp-t: buffer address 0x28000</pre>
<pre>   ttcp-t: File-Descriptor  fd 0x4 Closed</pre>
<pre>   ttcp done.</pre>
<br />
<pre>cpu seconds  ==  (sec) elapse ru_utime + elapse ru_stime.</pre>
<pre>                 ru_utime == The total amount of time running in user mode.</pre>
<pre>                 ru_stime == The total amount of time spent in the system.</pre>
<pre>                             executing on behalf of the process.</pre>
<pre>real seconds ==  elapse time calculated by the system timer (date).</pre>
<pre>I/O calls    ==  I/O call to the driver.</pre>
<pre>msec/call    ==  average elapse time (Real seconds) between each I/O.</pre>
<pre>calls/sec    ==  invert of msec/call.</pre>
<pre>user         ==  (sec.msec) elaspe ru_utime.</pre>
<pre>sys          ==  (sec.msec) elapse ru_stime.</pre>
<pre>real         ==  (min:sec)  CPU seconds.</pre>
<pre>%           ==  Real seconds / CPU seconds.</pre>
<pre>(ru_ixrss)i+(ru_idrss)d</pre>
<pre>             ru_ixrss  == An integral value indicating the amount of memory </pre>
<pre>                          used by the text segment that was also shared among</pre>
<pre>                          other processes. This value is expressed in units of</pre>
<pre>                          kilobytes * seconds-of-execution and is calculated </pre>
<pre>                          by adding the number of shared memory pages in use </pre>
<pre>                          each time the internal system clock ticks, and then</pre>
<pre>                          averaging over one-second intervals.</pre>
<pre>             ru_idrss  == An integral value of the amount of unshared memory </pre>
<pre>                          in the data segment of a process (expressed in </pre>
<pre>                          units of kilobytes * seconds-of-execution).</pre>
<pre>  (ru_maxrss/2)maxrss.</pre>
<pre>             ru_maxrss == The maximum size, in kilobytes, of the used</pre>
<pre>                          resident set size. </pre>
<pre>  (ru_majflt)+(ru_minflt)pf : Page fault</pre>
<pre>             ru_majflt == The number of page faults serviced that required</pre>
<pre>                          I/O activity.</pre>
<pre>             ru_minflt == The number of page faults serviced without any</pre>
<pre>                          I/O activity. In this case, I/O activity is </pre>
<pre>                          avoided by reclaiming a page frame from the list </pre>
<pre>                          of pages awaiting reallocation. </pre>
<pre>(ru_nvcsw)+(ru_nivcsw)csw : context switch</pre>
<pre>             ru_nvcsw  == The number of times a context switch resulted </pre>
<pre>                          because a process voluntarily gave up the </pre>
<pre>                          processor before its time slice was completed. </pre>
<pre>                          This usually occurs while the process waits </pre>
<pre>                          for availability of a resource.</pre>
<pre>             ru_nivcsw == The number of times a context switch resulted </pre>
<pre>                          because a higher priority process ran or because</pre>
<pre>                          the current process exceeded its time slice.</pre>
<br />
<pre>log file format :</pre>
<pre>         buflen, nbuf(byte), bufalign(byte), bufoffset(byte)</pre>
<pre>         port, sockbufsize(byte), UserTime(sec), SysTime(sec), CPUusage(%)</pre>
<pre>         nbytes(byte), realt(sec), rate(MB/sec), I/O call,</pre>
<pre>                 hours*3600+min*60+sec</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">--help</span></pre>
<pre>./usr/sbin/epi_ttcp: invalid option -- '-'</pre>
<pre>  Usage: ttcp -t [-options] host [ &lt; in ]    ttcp -r [-options &gt; out]</pre>
<pre>Example: ttcp -t -s -v -n100 host            ttcp -r -s -v -n100</pre>
<pre>Common options:</pre>
<pre>    -V      prints version number and date of last modification</pre>
<pre>    -L      create and append all results to a file named ttcp_log</pre>
<pre>    -h      more help</pre>
<pre>    -l ##   length of bufs read from or written to network (default 8192,</pre>
<pre>            max 65535)</pre>
<pre>    -u      use UDP instead of TCP</pre>
<pre>    -p ##   port number to send to or listen at (default 5010)</pre>
<pre>    -P ##   link-layer priority (default 0)</pre>
<pre>    -s      (ttcp -t) : source a pattern to network</pre>
<pre>            (ttcp -r) : sink (discard) all data from network</pre>
<pre>    -A ##   align the start of buffers to this modulus (default 16384)</pre>
<pre>    -O ##   start buffers at this offset from the modulus (default 0)</pre>
<pre>    -v      verbose: print more statistics</pre>
<pre>    -d      set SO_DEBUG socket option</pre>
<pre>    -b ##   set socket buffer size (if supported)</pre>
<pre>    -f X    format for rate: b,B = bits, bytes k,K = kilo{bits,bytes};</pre>
<pre>                             m,M = mega{bits,bytes}; g,G = giga{bits,bytes}</pre>
<pre>    -w ##   set timeout value (in milliseconds) to exit if no receive data or tcp connect</pre>
<pre>Options specific to (ttcp -t) :</pre>
<pre>    -n ##   number of source bufs written to network (default 2048)</pre>
<pre>    -x      use random data in tcp/udp frames (-I provides seed)</pre>
<pre>    -D      don't buffer TCP writes (sets TCP_NODELAY socket option)</pre>
<pre>    -H      print hash marks to indicate progress, one per buffer</pre>
<pre>    -# ##   number of buffers to send between hash marks (implies -H)</pre>
<pre>    -I      init/seed value for RNG when sending random size bufs (default 1)</pre>
<pre>    -N ##   number of source bufs per burst, i.e between sleeps (default 1)</pre>
<pre>    -R ##   send random size buffers with minimum size specified, max size</pre>
<pre>            is value of -l option</pre>
<pre>    -S ##   millisecs between bursts (10ms resolution)</pre>
<pre>Options specific to (ttcp -r) :</pre>
<pre>    -B      for -s, only output full blocks as specified by -l (for TAR)</pre>
<pre>    -T      "touch": access each byte as it's read</pre>
<pre>    -i      report information on out of order sequence numbers</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">--version</span></pre>
<pre>./usr/sbin/epi_ttcp: invalid option -- '-'</pre>
<pre>  Usage: ttcp -t [-options] host [ &lt; in ]    ttcp -r [-options &gt; out]</pre>
<pre>Example: ttcp -t -s -v -n100 host            ttcp -r -s -v -n100</pre>
<pre>Common options:</pre>
<pre>    -V      prints version number and date of last modification</pre>
<pre>    -L      create and append all results to a file named ttcp_log</pre>
<pre>    -h      more help</pre>
<pre>    -l ##   length of bufs read from or written to network (default 8192,</pre>
<pre>            max 65535)</pre>
<pre>    -u      use UDP instead of TCP</pre>
<pre>    -p ##   port number to send to or listen at (default 5010)</pre>
<pre>    -P ##   link-layer priority (default 0)</pre>
<pre>    -s      (ttcp -t) : source a pattern to network</pre>
<pre>            (ttcp -r) : sink (discard) all data from network</pre>
<pre>    -A ##   align the start of buffers to this modulus (default 16384)</pre>
<pre>    -O ##   start buffers at this offset from the modulus (default 0)</pre>
<pre>    -v      verbose: print more statistics</pre>
<pre>    -d      set SO_DEBUG socket option</pre>
<pre>    -b ##   set socket buffer size (if supported)</pre>
<pre>    -f X    format for rate: b,B = bits, bytes k,K = kilo{bits,bytes};</pre>
<pre>                             m,M = mega{bits,bytes}; g,G = giga{bits,bytes}</pre>
<pre>    -w ##   set timeout value (in milliseconds) to exit if no receive data or tcp connect</pre>
<pre>Options specific to (ttcp -t) :</pre>
<pre>    -n ##   number of source bufs written to network (default 2048)</pre>
<pre>    -x      use random data in tcp/udp frames (-I provides seed)</pre>
<pre>    -D      don't buffer TCP writes (sets TCP_NODELAY socket option)</pre>
<pre>    -H      print hash marks to indicate progress, one per buffer</pre>
<pre>    -# ##   number of buffers to send between hash marks (implies -H)</pre>
<pre>    -I      init/seed value for RNG when sending random size bufs (default 1)</pre>
<pre>    -N ##   number of source bufs per burst, i.e between sleeps (default 1)</pre>
<pre>    -R ##   send random size buffers with minimum size specified, max size</pre>
<pre>            is value of -l option</pre>
<pre>    -S ##   millisecs between bursts (10ms resolution)</pre>
<pre>Options specific to (ttcp -r) :</pre>
<pre>    -B      for -s, only output full blocks as specified by -l (for TAR)</pre>
<pre>    -T      "touch": access each byte as it's read</pre>
<pre>    -i      report information on out of order sequence numbers</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/epi_ttcp</span> with parameter </span><span class="orange">version</span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>ttcp-r: bind: Address already in use</pre>
<pre>ttcp-r: errno=98</pre>
