<!-- 
EMBA - EMBEDDED LINUX ANALYZER

Copyright 2020-2023 Siemens AG
Copyright 2020-2023 Siemens Energy AG

EMBA comes with ABSOLUTELY NO WARRANTY. This is free software, and you are
welcome to redistribute it under the terms of the GNU General Public License.
See LICENSE file for usage of this software.

EMBA is licensed under GPLv3

Author(s): Pascal Eckmann
Contributor(s): Michael Messner, Stefan Haboeck
-->

<!-- Used icons: https://github.com/CoreyGinnivan/system-uicons -->
 
<!DOCTYPE html>
<html lang="en">
<head>
  <title>EMBA firmware report</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="./../style/style.css" type="text/css">
  <link rel="icon" type="image/png" href="./../style/favicon.png">
</head>
<body>

<div id="sidenav" class="side">
  <div id="logo">
    <a class="inherit" href="./../index.html"><img class="inherit" id="logoImage" src="./../style/emba.svg" alt="logo"></a>
  </div>
  <div id="nav">
      <a id="embark" class="hidden" href="{{ embarkBackUrl }}">&laquo; Back to EMBArk</a> <!-- nosem -->
      <a class="backButton" href="./../index.html">&laquo; Back to main</a>
<a class="modul" href="./../s115_usermode_emulator.html" title="./../s115_usermode_emulator.html" >&laquo; Back to s115_usermode_emulator</a>
      <!-- navigation start -->
      <!-- navigation end -->
      <input id="expand" class="expand_njs hidden" type="button" value="More results:" onclick="this.value=this.value=='+ Show more results'?'- Hide more results':'+ Show more results';">
      <div class="expand_area">
        <!-- etc start -->
        <!-- etc end -->
      </div>
  </div>
  <a href="TIMELINK"><div id="buttonTimeInvisible" class="rectButton"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round" transform="matrix(-1 0 0 1 19 2)"><circle cx="8.5" cy="8.5" r="8"/><path d="M8.5 5.5v4H5"/></g></svg></div></a>
  <div id="buttonSizer" class="rectButton buttonClose" onclick="buttonNav()"></div>
</div>
<div id="main" class="main">
  <!-- content start -->
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary name: </span><span class="orange">ethctl</span></pre>
<pre>[</span><span class="orange">*</span>] Emulator used: </span><span class="orange">qemu-arm-static</span></pre>
<pre>[</span><span class="orange">*</span>] Using root directory: </span><span class="orange">/logs/firmware/firmware_binwalk_emba/_firmware.extracted/squashfs-root</span> (</span><span class="orange">1/1</span>)</pre>
<pre>[</span><span class="orange">*</span>] Using CPU config: </span><span class="orange">NONE</span></pre>
<pre>[</span><span class="orange">*</span>] Emulating binary: </span><span class="orange">/bin/ethctl</span></pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">NONE</span></pre>
<pre>Not valid parameter NONE</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ] #  Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;] #  Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;] #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;] #  Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;] #  Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;] #  Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt; #  Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; stats #  Display software stats</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;] #  Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;] #  Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<br />
<pre>Not valid parameter NONE</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt; #  Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt; #  Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] #  Phy Access </pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]  #  Phy Access </pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;] #  Phy Access </pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy-map #  Display PHY to Kernel Net Device mapping information</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">-v</span></pre>
<pre>Not valid parameter -v</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ] #  Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;] #  Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;] #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;] #  Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;] #  Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;] #  Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt; #  Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; stats #  Display software stats</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;] #  Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;] #  Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<br />
<pre>Not valid parameter -v</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt; #  Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt; #  Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] #  Phy Access </pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]  #  Phy Access </pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;] #  Phy Access </pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy-map #  Display PHY to Kernel Net Device mapping information</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">-V</span></pre>
<pre>Not valid parameter -V</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ] #  Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;] #  Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;] #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;] #  Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;] #  Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;] #  Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt; #  Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; stats #  Display software stats</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;] #  Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;] #  Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<br />
<pre>Not valid parameter -V</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt; #  Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt; #  Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] #  Phy Access </pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]  #  Phy Access </pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;] #  Phy Access </pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy-map #  Display PHY to Kernel Net Device mapping information</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">-h</span></pre>
<pre>Interface specific commands:</pre>
<pre>Usage: ethctl &lt;interface&gt; &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>media-type:</pre>
<pre>: Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ]</pre>
<pre>    [option]: auto - auto select</pre>
<pre>              10000FD - 10Gb, Full Duplex</pre>
<pre>              5000FD - 5Gb, Full Duplex</pre>
<pre>              2500FD - 2.5Gb, Full Duplex</pre>
<pre>              1000FD - 1000Mb, Full Duplex</pre>
<pre>              1000HD - 1000Mb, Half Duplex</pre>
<pre>              100FD - 100Mb, Full Duplex</pre>
<pre>              100HD - 100Mb, Half Duplex</pre>
<pre>              10FD  - 10Mb,  Full Duplex</pre>
<pre>              10HD  - 10Mb,  Half Duplex</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-reset:</pre>
<pre>: Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-crossbar:</pre>
<pre>: Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: assign &lt;sub_port#&gt; to &lt;interface&gt;</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping</pre>
<br />
<pre>reg:</pre>
<pre>: Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-power:</pre>
<pre>: Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee:</pre>
<pre>: Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee-resolution:</pre>
<pre>: Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>apd:</pre>
<pre>: Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>vport:</pre>
<pre>: Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt;</pre>
<pre>stats:</pre>
<pre>: Display software stats</pre>
<pre>  ethctl &lt;interface&gt; stats</pre>
<pre>ethernet&commat;wirespeed:</pre>
<pre>: Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>cable-diag:</pre>
<pre>: Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    &lt;interface&gt;: Individual or "bcmsw" for all interfaces.</pre>
<pre>    [port &lt;sub_port#&gt;]: PHY port under an interface with Crossbar or Trunk port.</pre>
<pre>                        If it's omitted, all sub_ports will be listed.</pre>
<pre>    show: Display current Cable Diagnosis Setting.</pre>
<pre>    enable/diable: Enable/Diable Auto Cable Diag function in driver during the link changes.</pre>
<pre>    run: Run specific port Cable Diag function once manually.</pre>
<br />
<pre>phy-macsec:</pre>
<pre>: Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt;</pre>
<pre>     &lt;level&gt;: 0=error, 1=info, 2=debug</pre>
<pre>     &lt;direction&gt;: 0=Egress, 1=Ingress</pre>
<pre>     &lt;sc_index&gt;: int</pre>
<pre>     &lt;sa_index&gt;: int</pre>
<pre>     &lt;rule_index&gt;: int</pre>
<pre>     &lt;sci&gt;: 8 bytes in hex</pre>
<pre>     &lt;key&gt;: AES key in hex</pre>
<pre>     &lt;hkey&gt;: in hex</pre>
<pre>     &lt;key_size&gt;: AES key length in bytes &lt/24/32&gt;</pre>
<br />
<br />
<pre>Common commands:</pre>
<pre>Usage: ethctl &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>tx_iudma:</pre>
<pre>: Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt;</pre>
<pre>rx_iudma:</pre>
<pre>: Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt;</pre>
<br />
<pre>phy:</pre>
<pre>: Phy Access </pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]</pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] </pre>
<pre>      &lt;reg&gt;: 0-0x1f: CL22 IEEE register; 0x20-0xffff: Broadcom Extended Registers.</pre>
<pre>             0x1,0000-0x1f,ffff: CL45 IEEE Register, DeviceAddress + 2 byte Registers.</pre>
<pre>             0x20,0000-0xffff,ffff: Broadcom PHY 32bit address.</pre>
<pre>      &lt;ext32&gt;: Force to access Broadcom phy 32bit address.</pre>
<pre>      &lt;bus_num&gt;: I2C Bus Number:  0: 2.5G SFP Module</pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;]</pre>
<pre>      [&lt;power_mode&gt;]: 0 - No Power Saving - for Loopback, PRBS testing, Extenal Device Connection</pre>
<pre>                      1 - Basic Power Saving - power down before SFP insertion; default mode</pre>
<pre>                      2 - Advanced Power Saving - power down before link up</pre>
<pre>                      3 - Device Forced Power Off</pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>      Read/Write 10G Serdes/PCS registers</pre>
<pre>      &lt;reg&gt;: 10G AE register address including higher 16bits total 32bits</pre>
<pre>         Higher 16 Bit definitions:</pre>
<pre>             DEVID_0:0x0000, DEVID_1: 0x0800; PLL_0: 0x0000, PLL_1: 0x0100</pre>
<pre>             LANE_0-3: 0x0000-0x0003, LANE_BRDCST: 0x00FF</pre>
<pre>      -d: Dump registers started from &lt;reg&gt; to &lt;reg2&gt;.</pre>
<br />
<pre>phy-map:</pre>
<pre>: Display PHY to Kernel Net Device mapping information</pre>
<pre>  ethctl phy-map</pre>
<br />
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">-help</span></pre>
<pre>Interface specific commands:</pre>
<pre>Usage: ethctl &lt;interface&gt; &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>media-type:</pre>
<pre>: Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ]</pre>
<pre>    [option]: auto - auto select</pre>
<pre>              10000FD - 10Gb, Full Duplex</pre>
<pre>              5000FD - 5Gb, Full Duplex</pre>
<pre>              2500FD - 2.5Gb, Full Duplex</pre>
<pre>              1000FD - 1000Mb, Full Duplex</pre>
<pre>              1000HD - 1000Mb, Half Duplex</pre>
<pre>              100FD - 100Mb, Full Duplex</pre>
<pre>              100HD - 100Mb, Half Duplex</pre>
<pre>              10FD  - 10Mb,  Full Duplex</pre>
<pre>              10HD  - 10Mb,  Half Duplex</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-reset:</pre>
<pre>: Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-crossbar:</pre>
<pre>: Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: assign &lt;sub_port#&gt; to &lt;interface&gt;</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping</pre>
<br />
<pre>reg:</pre>
<pre>: Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-power:</pre>
<pre>: Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee:</pre>
<pre>: Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee-resolution:</pre>
<pre>: Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>apd:</pre>
<pre>: Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>vport:</pre>
<pre>: Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt;</pre>
<pre>stats:</pre>
<pre>: Display software stats</pre>
<pre>  ethctl &lt;interface&gt; stats</pre>
<pre>ethernet&commat;wirespeed:</pre>
<pre>: Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>cable-diag:</pre>
<pre>: Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    &lt;interface&gt;: Individual or "bcmsw" for all interfaces.</pre>
<pre>    [port &lt;sub_port#&gt;]: PHY port under an interface with Crossbar or Trunk port.</pre>
<pre>                        If it's omitted, all sub_ports will be listed.</pre>
<pre>    show: Display current Cable Diagnosis Setting.</pre>
<pre>    enable/diable: Enable/Diable Auto Cable Diag function in driver during the link changes.</pre>
<pre>    run: Run specific port Cable Diag function once manually.</pre>
<br />
<pre>phy-macsec:</pre>
<pre>: Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt;</pre>
<pre>     &lt;level&gt;: 0=error, 1=info, 2=debug</pre>
<pre>     &lt;direction&gt;: 0=Egress, 1=Ingress</pre>
<pre>     &lt;sc_index&gt;: int</pre>
<pre>     &lt;sa_index&gt;: int</pre>
<pre>     &lt;rule_index&gt;: int</pre>
<pre>     &lt;sci&gt;: 8 bytes in hex</pre>
<pre>     &lt;key&gt;: AES key in hex</pre>
<pre>     &lt;hkey&gt;: in hex</pre>
<pre>     &lt;key_size&gt;: AES key length in bytes &lt/24/32&gt;</pre>
<br />
<br />
<pre>Common commands:</pre>
<pre>Usage: ethctl &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>tx_iudma:</pre>
<pre>: Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt;</pre>
<pre>rx_iudma:</pre>
<pre>: Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt;</pre>
<br />
<pre>phy:</pre>
<pre>: Phy Access </pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]</pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] </pre>
<pre>      &lt;reg&gt;: 0-0x1f: CL22 IEEE register; 0x20-0xffff: Broadcom Extended Registers.</pre>
<pre>             0x1,0000-0x1f,ffff: CL45 IEEE Register, DeviceAddress + 2 byte Registers.</pre>
<pre>             0x20,0000-0xffff,ffff: Broadcom PHY 32bit address.</pre>
<pre>      &lt;ext32&gt;: Force to access Broadcom phy 32bit address.</pre>
<pre>      &lt;bus_num&gt;: I2C Bus Number:  0: 2.5G SFP Module</pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;]</pre>
<pre>      [&lt;power_mode&gt;]: 0 - No Power Saving - for Loopback, PRBS testing, Extenal Device Connection</pre>
<pre>                      1 - Basic Power Saving - power down before SFP insertion; default mode</pre>
<pre>                      2 - Advanced Power Saving - power down before link up</pre>
<pre>                      3 - Device Forced Power Off</pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>      Read/Write 10G Serdes/PCS registers</pre>
<pre>      &lt;reg&gt;: 10G AE register address including higher 16bits total 32bits</pre>
<pre>         Higher 16 Bit definitions:</pre>
<pre>             DEVID_0:0x0000, DEVID_1: 0x0800; PLL_0: 0x0000, PLL_1: 0x0100</pre>
<pre>             LANE_0-3: 0x0000-0x0003, LANE_BRDCST: 0x00FF</pre>
<pre>      -d: Dump registers started from &lt;reg&gt; to &lt;reg2&gt;.</pre>
<br />
<pre>phy-map:</pre>
<pre>: Display PHY to Kernel Net Device mapping information</pre>
<pre>  ethctl phy-map</pre>
<br />
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">--help</span></pre>
<pre>Interface specific commands:</pre>
<pre>Usage: ethctl &lt;interface&gt; &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>media-type:</pre>
<pre>: Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ]</pre>
<pre>    [option]: auto - auto select</pre>
<pre>              10000FD - 10Gb, Full Duplex</pre>
<pre>              5000FD - 5Gb, Full Duplex</pre>
<pre>              2500FD - 2.5Gb, Full Duplex</pre>
<pre>              1000FD - 1000Mb, Full Duplex</pre>
<pre>              1000HD - 1000Mb, Half Duplex</pre>
<pre>              100FD - 100Mb, Full Duplex</pre>
<pre>              100HD - 100Mb, Half Duplex</pre>
<pre>              10FD  - 10Mb,  Full Duplex</pre>
<pre>              10HD  - 10Mb,  Half Duplex</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-reset:</pre>
<pre>: Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-crossbar:</pre>
<pre>: Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: assign &lt;sub_port#&gt; to &lt;interface&gt;</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping</pre>
<br />
<pre>reg:</pre>
<pre>: Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>phy-power:</pre>
<pre>: Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee:</pre>
<pre>: Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>eee-resolution:</pre>
<pre>: Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>apd:</pre>
<pre>: Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>vport:</pre>
<pre>: Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt;</pre>
<pre>stats:</pre>
<pre>: Display software stats</pre>
<pre>  ethctl &lt;interface&gt; stats</pre>
<pre>ethernet&commat;wirespeed:</pre>
<pre>: Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    [port &lt;sub_port#&gt;]: required if &lt;interface&gt; has Crossbar or Trunk port underneath</pre>
<br />
<pre>cable-diag:</pre>
<pre>: Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;]</pre>
<pre>    &lt;interface&gt;: Individual or "bcmsw" for all interfaces.</pre>
<pre>    [port &lt;sub_port#&gt;]: PHY port under an interface with Crossbar or Trunk port.</pre>
<pre>                        If it's omitted, all sub_ports will be listed.</pre>
<pre>    show: Display current Cable Diagnosis Setting.</pre>
<pre>    enable/diable: Enable/Diable Auto Cable Diag function in driver during the link changes.</pre>
<pre>    run: Run specific port Cable Diag function once manually.</pre>
<br />
<pre>phy-macsec:</pre>
<pre>: Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt;</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt;</pre>
<pre>     &lt;level&gt;: 0=error, 1=info, 2=debug</pre>
<pre>     &lt;direction&gt;: 0=Egress, 1=Ingress</pre>
<pre>     &lt;sc_index&gt;: int</pre>
<pre>     &lt;sa_index&gt;: int</pre>
<pre>     &lt;rule_index&gt;: int</pre>
<pre>     &lt;sci&gt;: 8 bytes in hex</pre>
<pre>     &lt;key&gt;: AES key in hex</pre>
<pre>     &lt;hkey&gt;: in hex</pre>
<pre>     &lt;key_size&gt;: AES key length in bytes &lt/24/32&gt;</pre>
<br />
<br />
<pre>Common commands:</pre>
<pre>Usage: ethctl &lt;command&gt; [arguments...]</pre>
<pre>Use -h|--help to get details of each command.</pre>
<br />
<pre>tx_iudma:</pre>
<pre>: Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt;</pre>
<pre>rx_iudma:</pre>
<pre>: Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt;</pre>
<br />
<pre>phy:</pre>
<pre>: Phy Access </pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]</pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] </pre>
<pre>      &lt;reg&gt;: 0-0x1f: CL22 IEEE register; 0x20-0xffff: Broadcom Extended Registers.</pre>
<pre>             0x1,0000-0x1f,ffff: CL45 IEEE Register, DeviceAddress + 2 byte Registers.</pre>
<pre>             0x20,0000-0xffff,ffff: Broadcom PHY 32bit address.</pre>
<pre>      &lt;ext32&gt;: Force to access Broadcom phy 32bit address.</pre>
<pre>      &lt;bus_num&gt;: I2C Bus Number:  0: 2.5G SFP Module</pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;]</pre>
<pre>      [&lt;power_mode&gt;]: 0 - No Power Saving - for Loopback, PRBS testing, Extenal Device Connection</pre>
<pre>                      1 - Basic Power Saving - power down before SFP insertion; default mode</pre>
<pre>                      2 - Advanced Power Saving - power down before link up</pre>
<pre>                      3 - Device Forced Power Off</pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d]</pre>
<pre>      Read/Write 10G Serdes/PCS registers</pre>
<pre>      &lt;reg&gt;: 10G AE register address including higher 16bits total 32bits</pre>
<pre>         Higher 16 Bit definitions:</pre>
<pre>             DEVID_0:0x0000, DEVID_1: 0x0800; PLL_0: 0x0000, PLL_1: 0x0100</pre>
<pre>             LANE_0-3: 0x0000-0x0003, LANE_BRDCST: 0x00FF</pre>
<pre>      -d: Dump registers started from &lt;reg&gt; to &lt;reg2&gt;.</pre>
<br />
<pre>phy-map:</pre>
<pre>: Display PHY to Kernel Net Device mapping information</pre>
<pre>  ethctl phy-map</pre>
<br />
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">--version</span></pre>
<pre>Not valid parameter --version</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ] #  Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;] #  Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;] #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;] #  Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;] #  Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;] #  Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt; #  Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; stats #  Display software stats</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;] #  Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;] #  Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<br />
<pre>Not valid parameter --version</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt; #  Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt; #  Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] #  Phy Access </pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]  #  Phy Access </pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;] #  Phy Access </pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy-map #  Display PHY to Kernel Net Device mapping information</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./bin/ethctl</span> with parameter </span><span class="orange">version</span></pre>
<pre>Not valid parameter version</pre>
<pre>  ethctl &lt;interface&gt; media-type [option] [port &lt;sub_port#&gt; ] #  Set/Get media type</pre>
<pre>  ethctl &lt;interface&gt; phy-reset [port &lt;sub_port#&gt;] #  Soft reset the transceiver</pre>
<pre>  ethctl &lt;interface&gt; phy-crossbar [port &lt;sub_port#&gt;] #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl bcmsw phy-crossbar: list all port phy mapping #  Get/Move &lt;interface&gt; crossbar phys</pre>
<pre>  ethctl &lt;interface&gt; reg &lt;[0-31]&gt; [0xhhhh] [port &lt;sub_port#&gt;] #  Set/Get port mii register</pre>
<pre>  ethctl &lt;interface&gt; phy-power [&lt;up|down&gt;] [port &lt;sub_port#&gt;] #  Phy power &lt;up|down&gt;/status</pre>
<pre>  ethctl &lt;interface&gt; eee [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy EEE (Energy Efficient Ethernet) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; eee-resolution [port &lt;sub_port#&gt;] #  Get phy EEE (Energy Efficient Ethernet) resolution status</pre>
<pre>  ethctl &lt;interface&gt; apd [&lt;on|off&gt;] [port &lt;sub_port#&gt;] #  Get/Set local phy APD (Auto Power Down) status/&lt;on|off&gt;</pre>
<pre>  ethctl &lt;interface&gt; vport &lt;enable|disable|query&gt; #  Enable/disable/query Switch for VLAN port mapping</pre>
<pre>  ethctl &lt;interface&gt; stats #  Display software stats</pre>
<pre>  ethctl &lt;interface&gt; ethernet&commat;wirespeed &lt;show|enable|disable&gt; [port &lt;sub_port#&gt;] #  Enable/Disable ethernet&commat;wirespeed</pre>
<pre>  ethctl &lt;interface&gt; cable-diag &lt;show|enable|disable|run&gt; [port &lt;sub_port#&gt;] #  Enable/Disable/Run PHY Cable Diagnosis Function</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec set_log_level &lt;level&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec init #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec enable &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_add &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_remove &lt;direction&gt; &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_add &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; &lt;sci&gt; &lt;key&gt; &lt;hkey&gt; &lt;key_size&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_remove &lt;direction&gt; &lt;sc_index&gt; &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_add &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_remove &lt;direction&gt; &lt;sc_index&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rule_enable &lt;direction&gt; &lt;rule_index&gt; &lt;0|1&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_e_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec vport_i_stat_get &lt;sc_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec tcam_stat_get &lt;direction&gt; &lt;rule_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec rxcam_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_i_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<pre>  ethctl &lt;interface&gt; phy-macsec sa_e_stat_get &lt;sa_index&gt; #  Phy macsec operations</pre>
<br />
<pre>Not valid parameter version</pre>
<pre>  ethctl tx_iudma &lt;[1-4]&gt; #  Set/Get number of Tx iuDMA channels</pre>
<pre>  ethctl rx_iudma &lt;[1-4]&gt; #  Set/Get number of Rx iuDMA channels</pre>
<pre>  ethctl phy int|ext|extsw|ext32 &lt;phy_addr&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d] #  Phy Access </pre>
<pre>  ethctl phy i2c &lt;bus_num&gt; &lt;reg&gt; [&lt;value|reg2&gt; [no_read_back]] [-d]  #  Phy Access </pre>
<pre>  ethctl phy serdespower &lt;phy_addr&gt; [&lt;power_mode&gt;] #  Phy Access </pre>
<pre>  ethctl phy 10gserdes 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy 10gpcs 0 &lt;reg&gt; [&lt;value|reg2&gt;] [-d] #  Phy Access </pre>
<pre>  ethctl phy-map #  Display PHY to Kernel Net Device mapping information</pre>
<br />
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
  <!-- content end -->
</div>

<a href="https://github.com/e-m-b-a/emba" title="github.com/e-m-b-a/emba" target="_blank">
  <div id="buttonInfo" class="rectButtonVisible">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" transform="translate(2 2)"><g stroke="white" stroke-linecap="round" stroke-linejoin="round"><circle cx="8.5" cy="8.5" r="8"/><path d="M8.5 12.5v-4h-1"/><path d="M7.5 12.5h2"/></g><circle cx="8.5" cy="5.5" fill="white" r="1"/></g></svg>
  </div>
</a>
<div id="buttonBack" class="nonClickable rectButtonVisible"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><path d="M9.5 14.5l4-4l-4-4" fill="none" stroke="#444" stroke-linecap="round" stroke-linejoin="round"/></svg></div>
<div id="buttonForward" class="nonClickable rectButtonVisible"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><path d="M11.5 14.5l-4-4l4-4" fill="none" stroke="#444" stroke-linecap="round" stroke-linejoin="round"/></svg></div> 
<div id="buttonDown" class="rectButton" onclick="scrollDown()"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 6.5l-4 4l-4-4"/><path d="M14.5 10.5l-4 4l-4-4"/></g></svg></div>
<div id="buttonUp" class="rectButton" onclick="scrollUp()"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 14.5l4-4l4 4"/><path d="M6.5 10.5l4-4l4 4"/></g></svg></div> 

<script>
window.onload = function () {
  var buttons = document.getElementsByClassName("rectButton");
  for (let i=0; i<buttons.length; i++) {
    buttons[i].style.visibility = "visible";
  }
  var buttonDown = document.getElementById("buttonDown");
  buttonDown.classList.add('rectButtonVisible');
  buttonDown.classList.remove('rectButton');

  var buttonUp = document.getElementById("buttonUp");
  buttonUp.classList.add('rectButtonVisible');
  buttonUp.classList.remove('rectButton');
    
  var buttonSizer = document.getElementById("buttonSizer");
  buttonSizer.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M9.5 16.5v-4.978l-5-.022"/><path d="M18.5 2.5l-7 7"/><path d="M16.5 9.5l-5 .023V4.5"/><path d="M9.5 11.5l-7 7"/></g></svg>';
  if (document.getElementById("buttonTime") !== null) {
    var buttonTime = document.getElementById("buttonTime");
    buttonTime.style.bottom = "50px";
  }
  document.getElementById("expand").value = "+ Show more results";
  document.getElementById("expand").className += " expand";
  var embarkButton = document.getElementById("embark");
  if ( !(embarkButton.href.includes("embarkBackUrl")) ) {
    embarkButton.classList.remove('hidden');
    document.getElementById("logoImage").src = "./../style/embark.svg";
    document.getElementById("logo").style.background = "#2d2d2d";
  }
}

function openNav() {
  document.getElementById("sidenav").style.width = "250px";
  document.getElementById("main").style.marginLeft = "250px";
  document.getElementById("nav").style.visibility = "visible";
}

function closeNav() {
  document.getElementById("sidenav").style.width = "50px";
  document.getElementById("sidenav").scrollTop = 0;
  document.getElementById("main").style.marginLeft = "50px";
  document.getElementById("nav").style.visibility = "hidden";
}

function scrollDown() {
  window.scrollTo(0,document.body.scrollHeight);
}

function scrollUp() {
  window.scrollTo(0,0);
}

function buttonNav() {
  var button = document.getElementById("buttonSizer");
  if ( button.classList.contains('buttonOpen') ) {
    button.classList.remove('buttonOpen');
    button.classList.add('buttonClose');
    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M9.5 16.5v-4.978l-5-.022"/><path d="M18.5 2.5l-7 7"/><path d="M16.5 9.5l-5 .023V4.5"/><path d="M9.5 11.5l-7 7"/></g></svg>';
    openNav();
  } else if( button.classList.contains('buttonClose') ) {
    button.classList.remove('buttonClose');
    button.classList.add('buttonOpen');
    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M18.5 7.5v-5h-5"/><path d="M18.5 2.5l-6 5.929"/><path d="M7.5 18.5l-5 .023V13.5"/><path d="M8.5 12.5l-6 6"/></g></svg>';
    closeNav();
  };
}

document.onkeydown = function(e) {
    switch (e.keyCode) {
      case 37:
        document.getElementById("buttonForward").parentNode.click(); 
        break;
      case 39:
        document.getElementById("buttonBack").parentNode.click();       
        break;
    }
};
</script>

</body>
</html>
